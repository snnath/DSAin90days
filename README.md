# DSAin90days

day 1&2:learn about space and time complexity.

    day1
    Time complexity: best case(omega(1)), average case(theta(n)) and worst case(O(n)).
    Always worst case scenario is taken into consideration for coding.
    
    Space complexity: How much space is being consumed in the memory when an operation
    is being ran. How many vaariables are stored the memory. 
    
day3-10: recursion and backtracking.
    
    day2
    Recursion: call stack analogy, string reversal, decimal to binary, sum of natural numbers.
    Divide and conquer: Binary search, fibonacci, merge sort.
    Linked lists reversal. 1:15
    
    day3
    Merging two sorted linked lists. 
    Trees:inserting a value into a binary search tree. Print all leaf nodes. 1:40 (not much progress, got distracted and started solving fcc and codechef:)
    
    day4
    Backtracking: Solving recursive problem by trying to build every possible solution incrementally and removing those solutions that fail to satisfy the 
    constraints  of the problem at any point of time. Maze problems. 
    
    Permutation problem, count number of paths, RatinMaze problem and N-number queen 
    
    Learned dynamic memory allocation using: 
    memory allocation: malloc():ptr = (int*) malloc(100 * sizeof(int));
    contiguous allocation: calloc():ptr = (float*) calloc(25, sizeof(float));   
    free():used to dynamically dealocate the memory. it helps in keeping the memory clear by freeing it. 
    realloc(): used to dynamically re-allocate memory if memory was in short of the previously allocated memory using malloc() or calloc().
    
    Day5
    Got to know more about n-queen problema and bacaktrackking in general.
    
    
day 11-30- arrays, linked lists, stacks & queues.

    Day5
    Arrays and pointers. Pointers do not contain a value but rather the address to a variable. 
    
    Day6
    
    Linked Lists- they contain a value also the address of the next location where the value is stored. (didnt do much today, tired overall)
    
    day7
    Inserting elements is faster in linked lists. O(n)<O(1). And searching elements is faster in arrays. O(1)<O(n).
    single end, double ended and circular linked lists. 
    
    Insertion, deletion, print, checkSize. 
    
    Reversing a linked list
    1. Iterative: using 3 pointers, curr, prev and next. 
    2. Recursive: 
    
    day8
    
